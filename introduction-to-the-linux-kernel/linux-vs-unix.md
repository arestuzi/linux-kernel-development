# Linux VS 经典的Unix内核

Linux和Unix有一样的祖先， 一样的API， 现代Unix内核共享了各种各样的设计理念。 除此之外， Unix内核是一个典型的庞大的静态库。 这就意味着，它是一个单一，庞大的运行在单一地址空间中的可执行镜像。 Unix系统需要物理机有分页内存管理单元(memory management unit --- MMU), 这种硬件会让系统强制启动内存保护，并且为每个进程提供唯一的虚拟地址空间。 Linux之前也需要MMU，但是一些特定的版本也没有它也可以正常运行。 这种简介的设计，可以让Linux运行在没有MMU的非常小的嵌入式设备上， 但是从另一方面来讲，现在简单的嵌入式设备也在逐渐拥有一些更为复杂的功能，它们也会有内存管理单元。 本书中，我们主要关注基于MMU的硬件系统。

## 宏内核 VS 微内核 在设计上的区别

我们可以把内核分为两种主要的设计：宏内核和微内核（还有一种，exokernel（外核），主要用于一些研究系统）

宏内核是两种内核之间相对简单的设计，直到1980年，所有的内核都是按照这种方式来进行的设计。 宏内核是一种运行在单独的地址空间中的一个单独的进程。所以，这种内核在硬盘上就是一个大的静态二进制文件。 所有的内核服务都在一个庞大的内核地址空间来执行。所以在内核内的通信非常简单，因为所有的东西都是运行在相同地址空间的内核模式中。 内核可以像普通用户程序一样直接加载一些函数。支持这种模式的开发者认为用大内核的方法很简洁并且很高效。 大多数的Unix系统都是采用宏内核的设计。

微内核并不是一个单一的大的进程,而是按照功能不同分成了很多进程，我们把这类进程统称为服务器（server）。 理想情况下，只有server有权利运行在特权级模式下， 其他server运行在用户空间。 所有的server运行在不同的地址空间， 所以像宏内核哪有直接调用函数是无法实现的。 取而代之的是，微内核需要通过`消息传递`来进行通信，`消息传递`是内核中原生的一种进程间通信的机制，进程之间通过这种机制来互相发送消息。 另外，模块化的系统使得一个server可以被另一个server替换掉。

因为进程间通信的机制比直接进行函数调用要更消耗资源，因为它需要不停的在用户空间和内核空间进行上下文切换，而且消息传递还有不可避免的延迟和吞吐量限制，宏内核完全没有这方面的限制。所以，生产环境中的微内核限制把所有的server都运行在内核空间，去除了进程上下文切换所带来的影响，间接的实现了内核空间的函数调用。 Windows NT内核以及Mach 内核就是微内核的代表， 目前这两种系统在其最新版本中，都没有在用户空间运行server，从而打破了微内核的最初设计理念。

Linux则是一个宏内核，所以Linux完全运行在内核模式中一个大段的地址空间中。 但是Linux却引入了很多微内核好的方面。比如Linux也采用了模块化的设计，可以在内核内部实现抢占，支持内核线程，还可以动态加载代码到内核镜像中。 而且，Linux没有像微内核的设计那样存在性能问题，所有服务都是运行在内核模式，在内核模式直接调用函数，不需要用进程间通信的机制来传递数据。所以，Linux是一个模块化的，多线程的，自身可调度的内核，实用主义这次又占了山风。

Linus和其他内核开发者们一起在对Linux内核做贡献，所以他们会决定如何更好的发展Linux，而且不能忽略原本的Unix系统，尤其是Unix的API设计。 所以，因为Linux没有基于任何Unix变体进行开发，Linus和其公司可以自由的选择最好的解决方案来解决一些问题，或者发明一些新的解决方案。 以下是Linux内核和Unix内核之间一些最为显著的不同：
+ Linux支持动态加载内核模块。虽然Linux内核是一个宏内核，但是它可以按需动态加载和卸载内核模块。
+ Linux支持对称多处理器架构（SMP).虽然大多数商业Unix也支持此架构，但是传统的Unix系统还不支持。
+ Linux内核是`抢占式`内核。不想其他Unix变体，Linux内核可以抢占CPU执行任务，哪怕这个任务是在内核态执行。 其他商业Unix中， Solaris和IRIX也是抢占式内核，但是其他大多数Unix内核都是非抢占式的。
+ Linux提供的device class是一个面对对象的模型、支持热插拔和用户空间设备文件系统（sysfs）。
+ Linux即使自由的也是免费的。如果一项功能是没有任何价值而且不是什么好点子的话，内核开发者是没有义务来实现它的。 相反地， Linux是这样面对其代码修改的： 代码修改必须要可以解决真实世界里的一个问题。 简洁的设计和有效的执行方式使得一些商业Unix内核的功能，在Linux上并没有被考虑。 比如在内核内实现分页内存。

尽管他们有这么多区别，但是Linux仍然继承了Unix的很多衣钵。